{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime-corejs2/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.getDefaultRegistry = getDefaultRegistry;\nexports.getSchemaType = getSchemaType;\nexports.getWidget = getWidget;\nexports.hasWidget = hasWidget;\nexports.getDefaultFormState = getDefaultFormState;\nexports.getUiOptions = getUiOptions;\nexports.isObject = isObject;\nexports.mergeObjects = mergeObjects;\nexports.asNumber = asNumber;\nexports.orderProperties = orderProperties;\nexports.isConstant = isConstant;\nexports.toConstant = toConstant;\nexports.isSelect = isSelect;\nexports.isMultiSelect = isMultiSelect;\nexports.isFilesArray = isFilesArray;\nexports.isFixedItems = isFixedItems;\nexports.allowAdditionalItems = allowAdditionalItems;\nexports.optionsList = optionsList;\nexports.stubExistingAdditionalProperties = stubExistingAdditionalProperties;\nexports.resolveSchema = resolveSchema;\nexports.retrieveSchema = retrieveSchema;\nexports.deepEquals = deepEquals;\nexports.shouldRender = shouldRender;\nexports.toIdSchema = toIdSchema;\nexports.toPathSchema = toPathSchema;\nexports.parseDateString = parseDateString;\nexports.toDateString = toDateString;\nexports.pad = pad;\nexports.setState = setState;\nexports.dataURItoBlob = dataURItoBlob;\nexports.rangeSpec = rangeSpec;\nexports.getMatchingOption = getMatchingOption;\nexports.guessType = exports.ADDITIONAL_PROPERTY_FLAG = void 0;\n\nvar _toPrimitive2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/symbol/to-primitive\"));\n\nvar _set = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/set\"));\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/from\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/get-iterator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _isNan = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/number/is-nan\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/extends\"));\n\nvar _objectSpread3 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/objectSpread\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/objectWithoutProperties\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar ReactIs = _interopRequireWildcard(require(\"react-is\"));\n\nvar _fill = _interopRequireDefault(require(\"core-js/library/fn/array/fill\"));\n\nvar _validate = _interopRequireWildcard(require(\"./validate\"));\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return (0, _typeof2[\"default\"])(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if ((0, _typeof2[\"default\"])(input) !== \"object\" || input === null) return input;\n  var prim = input[_toPrimitive2[\"default\"]];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if ((0, _typeof2[\"default\"])(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nvar ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nexports.ADDITIONAL_PROPERTY_FLAG = ADDITIONAL_PROPERTY_FLAG;\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\n\nfunction getDefaultRegistry() {\n  return {\n    fields: require(\"./components/fields\")[\"default\"],\n    widgets: require(\"./components/widgets\")[\"default\"],\n    definitions: {},\n    formContext: {}\n  };\n}\n\nfunction getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\n\nfunction getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"options\"]);\n        return _react[\"default\"].createElement(Widget, (0, _extends2[\"default\"])({\n          options: (0, _objectSpread3[\"default\"])({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat((0, _typeof2[\"default\"])(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\n\nfunction hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(schema, parentDefaults, definitions) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, definitions);\n    return computeDefaults(refSchema, defaults, definitions, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, definitions, formData);\n    return computeDefaults(resolvedSchema, defaults, definitions, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema) {\n      return computeDefaults(itemSchema, undefined, definitions, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, definitions)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, definitions)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return (0, _keys[\"default\"])(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], definitions, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, definitions)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = (0, _isArray[\"default\"])(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = (0, _fill[\"default\"])(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, definitions)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nfunction getDefaultFormState(_schema, formData) {\n  var definitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, definitions, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], definitions, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData)) {\n    // Override schema defaults with form data.\n    return mergeObjects(defaults, formData);\n  }\n\n  if (formData === 0) {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n\nfunction getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return (0, _keys[\"default\"])(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return (0, _objectSpread3[\"default\"])({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return (0, _objectSpread3[\"default\"])({}, options, value);\n    }\n\n    return (0, _objectSpread3[\"default\"])({}, options, (0, _defineProperty2[\"default\"])({}, key.substring(3), value));\n  }, {});\n}\n\nfunction isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return (0, _typeof2[\"default\"])(thing) === \"object\" && thing !== null && !(0, _isArray[\"default\"])(thing);\n}\n\nfunction mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // Recursively merge deeply nested objects.\n\n  var acc = (0, _assign[\"default\"])({}, obj1); // Prevent mutation of source object.\n\n  return (0, _keys[\"default\"])(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && (0, _isArray[\"default\"])(left) && (0, _isArray[\"default\"])(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !(0, _isNan[\"default\"])(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\n\nfunction orderProperties(properties, order) {\n  if (!(0, _isArray[\"default\"])(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var extraneous = order.filter(function (prop) {\n    return prop !== \"*\" && !propertyHash[prop];\n  });\n\n  if (extraneous.length) {\n    console.warn(\"uiSchema order list contains extraneous \".concat(errorPropList(extraneous)));\n  }\n\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = (0, _toConsumableArray2[\"default\"])(orderFiltered);\n  complete.splice.apply(complete, [restIndex, 1].concat((0, _toConsumableArray2[\"default\"])(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\n\nfunction isConstant(schema) {\n  return (0, _isArray[\"default\"])(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\n\nfunction toConstant(schema) {\n  if ((0, _isArray[\"default\"])(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\n\nfunction isSelect(_schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, definitions);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if ((0, _isArray[\"default\"])(schema[\"enum\"])) {\n    return true;\n  } else if ((0, _isArray[\"default\"])(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\n\nfunction isMultiSelect(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, definitions);\n}\n\nfunction isFilesArray(schema, uiSchema) {\n  var definitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, definitions);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\n\nfunction isFixedItems(schema) {\n  return (0, _isArray[\"default\"])(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\n\nfunction allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\n\nfunction optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  }\n}\n\nfunction findSchemaDefinition($ref) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Extract and use the referenced definition if we have it.\n\n  var match = /^#\\/definitions\\/(.*)$/.exec($ref);\n\n  if (match && match[1]) {\n    var parts = match[1].split(\"/\");\n    var current = definitions;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator2[\"default\"])(parts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n        part = part.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n\n        while (current.hasOwnProperty(\"$ref\")) {\n          current = findSchemaDefinition(current.$ref, definitions);\n        }\n\n        if (current.hasOwnProperty(part)) {\n          current = current[part];\n        } else {\n          // No matching definition found, that's an error (bogus schema?)\n          throw new Error(\"Could not find a definition for \".concat($ref, \".\"));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return current;\n  } // No matching definition found, that's an error (bogus schema?)\n\n\n  throw new Error(\"Could not find a definition for \".concat($ref, \".\"));\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\n\nvar guessType = function guessType(value) {\n  if ((0, _isArray[\"default\"])(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if ((0, _typeof2[\"default\"])(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\n\nexports.guessType = guessType;\n\nfunction stubExistingAdditionalProperties(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Clone the schema so we don't ruin the consumer's original\n\n  schema = (0, _objectSpread3[\"default\"])({}, schema, {\n    properties: (0, _objectSpread3[\"default\"])({}, schema.properties)\n  });\n  (0, _keys[\"default\"])(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, definitions, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = (0, _objectSpread3[\"default\"])({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n  return schema;\n}\n\nfunction resolveSchema(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, definitions, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, definitions, formData);\n    return retrieveSchema(resolvedSchema, definitions, formData);\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, definitions, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, definitions); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = (0, _objectWithoutProperties2[\"default\"])(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n  return retrieveSchema((0, _objectSpread3[\"default\"])({}, $refSchema, localSchema), definitions, formData);\n}\n\nfunction retrieveSchema(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var resolvedSchema = resolveSchema(schema, definitions, formData);\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, definitions, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, definitions, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = (0, _objectWithoutProperties2[\"default\"])(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, definitions)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, definitions)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, definitions, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, definitions, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = (0, _objectWithoutProperties2[\"default\"])(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if ((0, _isArray[\"default\"])(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, definitions, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, definitions, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = (0, _isArray[\"default\"])(schema.required) ? (0, _from[\"default\"])(new _set[\"default\"]([].concat((0, _toConsumableArray2[\"default\"])(schema.required), (0, _toConsumableArray2[\"default\"])(additionallyRequired)))) : additionallyRequired;\n  return (0, _objectSpread3[\"default\"])({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, definitions, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, definitions, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = (0, _objectWithoutProperties2[\"default\"])(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!(0, _isArray[\"default\"])(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat((0, _typeof2[\"default\"])(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, definitions, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, definitions, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, definitions, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: (0, _defineProperty2[\"default\"])({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = (0, _validate[\"default\"])(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = (0, _objectWithoutProperties2[\"default\"])(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n  var dependentSchema = (0, _objectSpread3[\"default\"])({}, subschema, {\n    properties: dependentSubschema\n  });\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, definitions, formData));\n}\n\nfunction mergeSchemas(schema1, schema2) {\n  return mergeObjects(schema1, schema2, true);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nfunction deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/mozilla-services/react-jsonschema-form/issues/255\n    return true;\n  } else if ((0, _typeof2[\"default\"])(a) !== \"object\" || (0, _typeof2[\"default\"])(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = (0, _keys[\"default\"])(a);\n    var kb = (0, _keys[\"default\"])(b); // don't bother with stack acrobatics if there's nothing there\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n\n      if (!deepEquals(a[key], b[key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\n\nfunction shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n\nfunction toIdSchema(schema, id, definitions) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema) {\n    var _schema = retrieveSchema(schema, definitions, formData);\n\n    return toIdSchema(_schema, id, definitions, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, definitions, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(field, fieldId, definitions, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\n\nfunction toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var definitions = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema) {\n    var _schema = retrieveSchema(schema, definitions, formData);\n\n    return toPathSchema(_schema, name, definitions, formData);\n  }\n\n  if (schema.hasOwnProperty(\"items\") && (0, _isArray[\"default\"])(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), definitions, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), definitions, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\n\nfunction parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if ((0, _isNan[\"default\"])(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\n\nfunction toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n\nfunction pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\n\nfunction setState(instance, state, callback) {\n  var safeRenderCompletion = instance.props.safeRenderCompletion;\n\n  if (safeRenderCompletion) {\n    instance.setState(state, callback);\n  } else {\n    instance.setState(state);\n    setTimeout(callback, 0);\n  }\n}\n\nfunction dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\n\nfunction rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\n\nfunction getMatchingOption(formData, options, definitions) {\n  for (var i = 0; i < options.length; i++) {\n    // Assign the definitions to the option, otherwise the match can fail if\n    // the new option uses a $ref\n    var option = (0, _assign[\"default\"])({\n      definitions: definitions\n    }, options[i]); // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: (0, _keys[\"default\"])(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = (0, _extends2[\"default\"])({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = (0, _assign[\"default\"])({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if ((0, _validate.isValid)(augmentedSchema, formData)) {\n        return i;\n      }\n    } else if ((0, _validate.isValid)(options[i], formData)) {\n      return i;\n    }\n  }\n\n  return 0;\n}","map":{"version":3,"sources":["/Users/lucaspauker/projects/treehacks/meet/node_modules/react-jsonschema-form/lib/utils.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","_Object$defineProperty","exports","value","getDefaultRegistry","getSchemaType","getWidget","hasWidget","getDefaultFormState","getUiOptions","isObject","mergeObjects","asNumber","orderProperties","isConstant","toConstant","isSelect","isMultiSelect","isFilesArray","isFixedItems","allowAdditionalItems","optionsList","stubExistingAdditionalProperties","resolveSchema","retrieveSchema","deepEquals","shouldRender","toIdSchema","toPathSchema","parseDateString","toDateString","pad","setState","dataURItoBlob","rangeSpec","getMatchingOption","guessType","ADDITIONAL_PROPERTY_FLAG","_toPrimitive2","_set","_from","_getIterator2","_toConsumableArray2","_isNan","_assign","_defineProperty2","_isArray","_keys","_typeof2","_extends2","_objectSpread3","_objectWithoutProperties2","_react","ReactIs","_fill","_validate","_toPropertyKey","arg","key","_toPrimitive","String","input","hint","prim","undefined","res","call","TypeError","Number","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","array","checkboxes","files","fields","widgets","definitions","formContext","schema","type","properties","additionalProperties","Array","length","includes","find","widget","registeredWidgets","arguments","mergeOptions","Widget","MergedWidget","defaultOptions","defaultProps","options","_ref","_ref$options","props","createElement","isForwardRef","Error","concat","hasOwnProperty","registeredWidget","_registeredWidget","e","message","startsWith","computeDefaults","parentDefaults","rawFormData","includeUndefinedValues","formData","defaults","refSchema","findSchemaDefinition","$ref","resolvedSchema","resolveDependencies","items","map","itemSchema","oneOf","anyOf","reduce","acc","computedDefault","minItems","defaultsLength","defaultEntries","fillerSchema","additionalItems","fillerEntries","_schema","uiSchema","filter","indexOf","console","warn","component","substring","thing","File","obj1","obj2","concatArrays","left","right","test","n","valid","order","arrayToHash","arr","prev","curr","errorPropList","join","propertyHash","extraneous","prop","orderFiltered","orderHash","rest","restIndex","lastIndexOf","complete","splice","apply","altSchemas","every","uniqueItems","itemsSchema","format","item","i","label","enumNames","title","match","exec","parts","split","current","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","part","replace","err","isNaN","forEach","resolveReference","$refSchema","localSchema","hasAdditionalProperties","_schema$dependencies","dependencies","processDependencies","dependencyKey","dependencyValue","remainingDependencies","withDependentProperties","withDependentSchema","additionallyRequired","required","_retrieveSchema","dependentSchema","mergeSchemas","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","_validateFormData","errors","_subschema$properties","dependentSubschema","schema1","schema2","isArguments","object","Object","prototype","toString","a","b","ca","cb","Date","getTime","RegExp","source","global","multiline","lastIndex","ignoreCase","slice","constructor","ka","kb","cal","push","sort","j","k","pop","comp","nextProps","nextState","state","id","idPrefix","idSchema","$id","name","field","fieldId","pathSchema","$name","element","property","dateString","includeTime","year","month","day","hour","minute","second","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","_ref2","_ref2$hour","_ref2$minute","_ref2$second","time","utcTime","UTC","toJSON","num","size","s","instance","callback","safeRenderCompletion","setTimeout","dataURI","splitted","params","param","binary","atob","charCodeAt","blob","window","Blob","Uint8Array","spec","multipleOf","step","minimum","min","maximum","max","option","requiresAnyOf","augmentedSchema","shallowClone","allOf","isValid"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime-corejs2/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.getDefaultRegistry = getDefaultRegistry;\nexports.getSchemaType = getSchemaType;\nexports.getWidget = getWidget;\nexports.hasWidget = hasWidget;\nexports.getDefaultFormState = getDefaultFormState;\nexports.getUiOptions = getUiOptions;\nexports.isObject = isObject;\nexports.mergeObjects = mergeObjects;\nexports.asNumber = asNumber;\nexports.orderProperties = orderProperties;\nexports.isConstant = isConstant;\nexports.toConstant = toConstant;\nexports.isSelect = isSelect;\nexports.isMultiSelect = isMultiSelect;\nexports.isFilesArray = isFilesArray;\nexports.isFixedItems = isFixedItems;\nexports.allowAdditionalItems = allowAdditionalItems;\nexports.optionsList = optionsList;\nexports.stubExistingAdditionalProperties = stubExistingAdditionalProperties;\nexports.resolveSchema = resolveSchema;\nexports.retrieveSchema = retrieveSchema;\nexports.deepEquals = deepEquals;\nexports.shouldRender = shouldRender;\nexports.toIdSchema = toIdSchema;\nexports.toPathSchema = toPathSchema;\nexports.parseDateString = parseDateString;\nexports.toDateString = toDateString;\nexports.pad = pad;\nexports.setState = setState;\nexports.dataURItoBlob = dataURItoBlob;\nexports.rangeSpec = rangeSpec;\nexports.getMatchingOption = getMatchingOption;\nexports.guessType = exports.ADDITIONAL_PROPERTY_FLAG = void 0;\n\nvar _toPrimitive2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/symbol/to-primitive\"));\n\nvar _set = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/set\"));\n\nvar _from = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/from\"));\n\nvar _getIterator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/get-iterator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/toConsumableArray\"));\n\nvar _isNan = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/number/is-nan\"));\n\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/assign\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/defineProperty\"));\n\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/array/is-array\"));\n\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/object/keys\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/typeof\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/extends\"));\n\nvar _objectSpread3 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/objectSpread\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/objectWithoutProperties\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar ReactIs = _interopRequireWildcard(require(\"react-is\"));\n\nvar _fill = _interopRequireDefault(require(\"core-js/library/fn/array/fill\"));\n\nvar _validate = _interopRequireWildcard(require(\"./validate\"));\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2[\"default\"])(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2[\"default\"])(input) !== \"object\" || input === null) return input; var prim = input[_toPrimitive2[\"default\"]]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2[\"default\"])(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nvar ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nexports.ADDITIONAL_PROPERTY_FLAG = ADDITIONAL_PROPERTY_FLAG;\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\n\nfunction getDefaultRegistry() {\n  return {\n    fields: require(\"./components/fields\")[\"default\"],\n    widgets: require(\"./components/widgets\")[\"default\"],\n    definitions: {},\n    formContext: {}\n  };\n}\n\nfunction getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\n\nfunction getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = (0, _objectWithoutProperties2[\"default\"])(_ref, [\"options\"]);\n        return _react[\"default\"].createElement(Widget, (0, _extends2[\"default\"])({\n          options: (0, _objectSpread3[\"default\"])({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat((0, _typeof2[\"default\"])(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\n\nfunction hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(schema, parentDefaults, definitions) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, definitions);\n    return computeDefaults(refSchema, defaults, definitions, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, definitions, formData);\n    return computeDefaults(resolvedSchema, defaults, definitions, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema) {\n      return computeDefaults(itemSchema, undefined, definitions, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, definitions)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, definitions)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return (0, _keys[\"default\"])(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], definitions, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, definitions)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = (0, _isArray[\"default\"])(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = (0, _fill[\"default\"])(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, definitions)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nfunction getDefaultFormState(_schema, formData) {\n  var definitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, definitions, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], definitions, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData)) {\n    // Override schema defaults with form data.\n    return mergeObjects(defaults, formData);\n  }\n\n  if (formData === 0) {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n\nfunction getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return (0, _keys[\"default\"])(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return (0, _objectSpread3[\"default\"])({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return (0, _objectSpread3[\"default\"])({}, options, value);\n    }\n\n    return (0, _objectSpread3[\"default\"])({}, options, (0, _defineProperty2[\"default\"])({}, key.substring(3), value));\n  }, {});\n}\n\nfunction isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return (0, _typeof2[\"default\"])(thing) === \"object\" && thing !== null && !(0, _isArray[\"default\"])(thing);\n}\n\nfunction mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Recursively merge deeply nested objects.\n  var acc = (0, _assign[\"default\"])({}, obj1); // Prevent mutation of source object.\n\n  return (0, _keys[\"default\"])(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && (0, _isArray[\"default\"])(left) && (0, _isArray[\"default\"])(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !(0, _isNan[\"default\"])(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\n\nfunction orderProperties(properties, order) {\n  if (!(0, _isArray[\"default\"])(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var extraneous = order.filter(function (prop) {\n    return prop !== \"*\" && !propertyHash[prop];\n  });\n\n  if (extraneous.length) {\n    console.warn(\"uiSchema order list contains extraneous \".concat(errorPropList(extraneous)));\n  }\n\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = (0, _toConsumableArray2[\"default\"])(orderFiltered);\n  complete.splice.apply(complete, [restIndex, 1].concat((0, _toConsumableArray2[\"default\"])(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\n\nfunction isConstant(schema) {\n  return (0, _isArray[\"default\"])(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\n\nfunction toConstant(schema) {\n  if ((0, _isArray[\"default\"])(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\n\nfunction isSelect(_schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, definitions);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if ((0, _isArray[\"default\"])(schema[\"enum\"])) {\n    return true;\n  } else if ((0, _isArray[\"default\"])(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\n\nfunction isMultiSelect(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, definitions);\n}\n\nfunction isFilesArray(schema, uiSchema) {\n  var definitions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, definitions);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\n\nfunction isFixedItems(schema) {\n  return (0, _isArray[\"default\"])(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\n\nfunction allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\n\nfunction optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  }\n}\n\nfunction findSchemaDefinition($ref) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Extract and use the referenced definition if we have it.\n  var match = /^#\\/definitions\\/(.*)$/.exec($ref);\n\n  if (match && match[1]) {\n    var parts = match[1].split(\"/\");\n    var current = definitions;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _getIterator2[\"default\"])(parts), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n        part = part.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n\n        while (current.hasOwnProperty(\"$ref\")) {\n          current = findSchemaDefinition(current.$ref, definitions);\n        }\n\n        if (current.hasOwnProperty(part)) {\n          current = current[part];\n        } else {\n          // No matching definition found, that's an error (bogus schema?)\n          throw new Error(\"Could not find a definition for \".concat($ref, \".\"));\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return current;\n  } // No matching definition found, that's an error (bogus schema?)\n\n\n  throw new Error(\"Could not find a definition for \".concat($ref, \".\"));\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\n\nvar guessType = function guessType(value) {\n  if ((0, _isArray[\"default\"])(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if ((0, _typeof2[\"default\"])(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\n\nexports.guessType = guessType;\n\nfunction stubExistingAdditionalProperties(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Clone the schema so we don't ruin the consumer's original\n  schema = (0, _objectSpread3[\"default\"])({}, schema, {\n    properties: (0, _objectSpread3[\"default\"])({}, schema.properties)\n  });\n  (0, _keys[\"default\"])(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, definitions, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = (0, _objectSpread3[\"default\"])({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n  return schema;\n}\n\nfunction resolveSchema(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, definitions, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, definitions, formData);\n    return retrieveSchema(resolvedSchema, definitions, formData);\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, definitions, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, definitions); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = (0, _objectWithoutProperties2[\"default\"])(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n  return retrieveSchema((0, _objectSpread3[\"default\"])({}, $refSchema, localSchema), definitions, formData);\n}\n\nfunction retrieveSchema(schema) {\n  var definitions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var resolvedSchema = resolveSchema(schema, definitions, formData);\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, definitions, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, definitions, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = (0, _objectWithoutProperties2[\"default\"])(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, definitions)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, definitions)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, definitions, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, definitions, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = (0, _objectWithoutProperties2[\"default\"])(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if ((0, _isArray[\"default\"])(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, definitions, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, definitions, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = (0, _isArray[\"default\"])(schema.required) ? (0, _from[\"default\"])(new _set[\"default\"]([].concat((0, _toConsumableArray2[\"default\"])(schema.required), (0, _toConsumableArray2[\"default\"])(additionallyRequired)))) : additionallyRequired;\n  return (0, _objectSpread3[\"default\"])({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, definitions, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, definitions, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = (0, _objectWithoutProperties2[\"default\"])(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!(0, _isArray[\"default\"])(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat((0, _typeof2[\"default\"])(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, definitions, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, definitions, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, definitions, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: (0, _defineProperty2[\"default\"])({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = (0, _validate[\"default\"])(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = (0, _objectWithoutProperties2[\"default\"])(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n  var dependentSchema = (0, _objectSpread3[\"default\"])({}, subschema, {\n    properties: dependentSubschema\n  });\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, definitions, formData));\n}\n\nfunction mergeSchemas(schema1, schema2) {\n  return mergeObjects(schema1, schema2, true);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nfunction deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/mozilla-services/react-jsonschema-form/issues/255\n    return true;\n  } else if ((0, _typeof2[\"default\"])(a) !== \"object\" || (0, _typeof2[\"default\"])(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = (0, _keys[\"default\"])(a);\n    var kb = (0, _keys[\"default\"])(b); // don't bother with stack acrobatics if there's nothing there\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      key = ka[k];\n\n      if (!deepEquals(a[key], b[key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\n\nfunction shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n\nfunction toIdSchema(schema, id, definitions) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema) {\n    var _schema = retrieveSchema(schema, definitions, formData);\n\n    return toIdSchema(_schema, id, definitions, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, definitions, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(field, fieldId, definitions, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\n\nfunction toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var definitions = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema) {\n    var _schema = retrieveSchema(schema, definitions, formData);\n\n    return toPathSchema(_schema, name, definitions, formData);\n  }\n\n  if (schema.hasOwnProperty(\"items\") && (0, _isArray[\"default\"])(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), definitions, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), definitions, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\n\nfunction parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if ((0, _isNan[\"default\"])(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\n\nfunction toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n\nfunction pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\n\nfunction setState(instance, state, callback) {\n  var safeRenderCompletion = instance.props.safeRenderCompletion;\n\n  if (safeRenderCompletion) {\n    instance.setState(state, callback);\n  } else {\n    instance.setState(state);\n    setTimeout(callback, 0);\n  }\n}\n\nfunction dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\n\nfunction rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\n\nfunction getMatchingOption(formData, options, definitions) {\n  for (var i = 0; i < options.length; i++) {\n    // Assign the definitions to the option, otherwise the match can fail if\n    // the new option uses a $ref\n    var option = (0, _assign[\"default\"])({\n      definitions: definitions\n    }, options[i]); // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: (0, _keys[\"default\"])(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = (0, _extends2[\"default\"])({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = (0, _assign[\"default\"])({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if ((0, _validate.isValid)(augmentedSchema, formData)) {\n        return i;\n      }\n    } else if ((0, _validate.isValid)(options[i], formData)) {\n      return i;\n    }\n  }\n\n  return 0;\n}"]},"metadata":{},"sourceType":"script"}